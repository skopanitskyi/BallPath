Для решения поставленной задачи используется алгоритм поиска в ширину. Этот алгоритм позволяет найти самый
короткий путь из точки А в точку В, в случае если такой существует.

Принцип работы:

Для реализации алгоритма используется вспомогательная структура данных - "Очередь", которая работает по принципу
FIFO. Стартовая ячейка добавляется в очередь, и исходя из ее координат ищутся соседние, которые
соответствуют условию: ячейка не содержит шар, ячейка не была ранее посещена. Все найденные ячейки добавляются в
очередь, также их переменной distanceIndex, отвечающей за количество переходов которое нужно сделать от текущей
ячейки к стартовой, устанавливается значение distanceIndex родительской ячейки + 1. После того как все соседние
ячейки были добавлены, стартовая ячейка удаляется из очереди. Процесс повторяется снова, и мы добавляем в очередь
все соседние ячейки тех, которые уже находятся в очереди. Обход завершится когда выполнится одно из условий:
все ячейки игрового поля будут пройдены, или мы дошли до конечной ячейки.

После завершения обхода происходит проверка значения distanceIndex в финальной ячейке. Если значение отсутствует,
тогда из стартовой в финальную ячейку пути нет, и в консоль выводится соответствующие сообщение. В случае если
значение имеется, тогда оно сообщает о минимальном количестве шагов, которое нужно сделать, чтобы попасть
в стартовую точку. И нам нужно восстановить путь от финальной точки к стартовой используя distanceIndex.

Перед восстановлением пути, значение stepToFinalPoint финальной ячейки устанавливается на 'F'. После чего мы
ищем соседнюю ячейку, которая не имеет шара и ее значение distanceIndex отличается на единицу меньше финальной
ячейки. Значение stepToFinalPoint найденной ячейки устанавливается на 'L', 'R', 'U' или 'D', в зависимости
от местоположения финальной ячейки. При этом все шаги также сохраняются в буферную переменную. После
повторяем операцию, и снова ищем ячейку без шара и значением stepToFinalPoint на единицу меньше ранее
найденной ячейки, устанавливаем значение stepToFinalPoint. Повторяем до тех пор, пока не дойдем до ячейки
со значением переменной distanceIndex ноль, это и будет стартовая ячейка. После восстановления получается, что
каждая ячейка участвующая в маршруте знает направление шага, который нужно сделать от нее, чтобы добраться
до финальной точки.

После остается только вывести на консоль количество шагов для преодоления маршрута, кратчайший путь и матрицу
игрового поля.


Скорость поиска:

В худшем случае скорость поиска кратчайшего пути O(V+E), где V - количество вершин, E - количество ребер.


Преимущества:

- Легок в реализации
- Применим к любой задаче поиска
- Всегда находит кратчайший путь, если он существует.


Недостатки:

-Необходимость прохождения большого числа сторонних узлов, что отрицательно сказывается на объеме используемой
памяти, а также скорости работы.